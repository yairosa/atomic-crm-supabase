create table "public"."companies" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "sector" text,
    "size" smallint,
    "linkedin_url" text,
    "website" text,
    "phone_number" text,
    "address" text,
    "zipcode" text,
    "city" text,
    "stateAbbr" text,
    "sales_id" bigint,
    "context_links" json,
    "country" text,
    "description" text,
    "revenue" text,
    "tax_identifier" text,
    "logo" jsonb
);


alter table "public"."companies" enable row level security;

create table "public"."contactNotes" (
    "id" bigint generated by default as identity not null,
    "contact_id" bigint not null,
    "text" text,
    "date" timestamp with time zone default now(),
    "sales_id" bigint,
    "status" text,
    "attachments" jsonb[]
);


alter table "public"."contactNotes" enable row level security;

create table "public"."contacts" (
    "id" bigint generated by default as identity not null,
    "first_name" text,
    "last_name" text,
    "gender" text,
    "title" text,
    "email" text,
    "phone_1_number" text,
    "phone_1_type" text,
    "phone_2_number" text,
    "phone_2_type" text,
    "background" text,
    "acquisition" text,
    "avatar" jsonb,
    "first_seen" timestamp with time zone,
    "last_seen" timestamp with time zone,
    "has_newsletter" boolean,
    "status" text,
    "tags" bigint[],
    "company_id" bigint,
    "sales_id" bigint,
    "linkedin_url" text
);


alter table "public"."contacts" enable row level security;

create table "public"."dealNotes" (
    "id" bigint generated by default as identity not null,
    "deal_id" bigint not null,
    "type" text,
    "text" text,
    "date" timestamp with time zone default now(),
    "sales_id" bigint,
    "attachments" jsonb[]
);


alter table "public"."dealNotes" enable row level security;

create table "public"."deals" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "company_id" bigint,
    "contact_ids" bigint[],
    "category" text,
    "stage" text not null,
    "description" text,
    "amount" bigint,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "archived_at" timestamp with time zone default null,
    "expected_closing_date" timestamp with time zone default null,
    "sales_id" bigint,
    "index" smallint
);


alter table "public"."deals" enable row level security;

create table "public"."sales" (
    "id" bigint generated by default as identity not null,
    "first_name" text not null,
    "last_name" text not null,
    "email" text not null,
    "administrator" boolean not null,
    "user_id" uuid not null,
    "avatar" jsonb,
    "disabled" boolean not null default FALSE
);


alter table "public"."sales" enable row level security;

create table "public"."tags" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "color" text not null
);


alter table "public"."tags" enable row level security;

create table "public"."tasks" (
    "id" bigint generated by default as identity not null,
    "contact_id" bigint not null,
    "type" text,
    "text" text,
    "due_date" timestamp with time zone not null,
    "done_date" timestamp with time zone
);


alter table "public"."tasks" enable row level security;

CREATE UNIQUE INDEX companies_pkey ON public.companies USING btree (id);

CREATE UNIQUE INDEX "contactNotes_pkey" ON public."contactNotes" USING btree (id);

CREATE UNIQUE INDEX contacts_pkey ON public.contacts USING btree (id);

CREATE UNIQUE INDEX "dealNotes_pkey" ON public."dealNotes" USING btree (id);

CREATE UNIQUE INDEX deals_pkey ON public.deals USING btree (id);

CREATE UNIQUE INDEX sales_pkey ON public.sales USING btree (id);

CREATE UNIQUE INDEX tags_pkey ON public.tags USING btree (id);

CREATE UNIQUE INDEX tasks_pkey ON public.tasks USING btree (id);

alter table "public"."companies" add constraint "companies_pkey" PRIMARY KEY using index "companies_pkey";

alter table "public"."contactNotes" add constraint "contactNotes_pkey" PRIMARY KEY using index "contactNotes_pkey";

alter table "public"."contacts" add constraint "contacts_pkey" PRIMARY KEY using index "contacts_pkey";

alter table "public"."dealNotes" add constraint "dealNotes_pkey" PRIMARY KEY using index "dealNotes_pkey";

alter table "public"."deals" add constraint "deals_pkey" PRIMARY KEY using index "deals_pkey";

alter table "public"."sales" add constraint "sales_pkey" PRIMARY KEY using index "sales_pkey";

alter table "public"."tags" add constraint "tags_pkey" PRIMARY KEY using index "tags_pkey";

alter table "public"."tasks" add constraint "tasks_pkey" PRIMARY KEY using index "tasks_pkey";

alter table "public"."companies" add constraint "companies_sales_id_fkey" FOREIGN KEY (sales_id) REFERENCES sales(id) not valid;

alter table "public"."companies" validate constraint "companies_sales_id_fkey";

alter table "public"."contactNotes" add constraint "contactNotes_contact_id_fkey" FOREIGN KEY (contact_id) REFERENCES contacts(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."contactNotes" validate constraint "contactNotes_contact_id_fkey";

alter table "public"."contactNotes" add constraint "contactNotes_sales_id_fkey" FOREIGN KEY (sales_id) REFERENCES sales(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."contactNotes" validate constraint "contactNotes_sales_id_fkey";

alter table "public"."contacts" add constraint "contacts_company_id_fkey" FOREIGN KEY (company_id) REFERENCES companies(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."contacts" validate constraint "contacts_company_id_fkey";

alter table "public"."contacts" add constraint "contacts_sales_id_fkey" FOREIGN KEY (sales_id) REFERENCES sales(id) not valid;

alter table "public"."contacts" validate constraint "contacts_sales_id_fkey";

alter table "public"."dealNotes" add constraint "dealNotes_deal_id_fkey" FOREIGN KEY (deal_id) REFERENCES deals(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."dealNotes" validate constraint "dealNotes_deal_id_fkey";

alter table "public"."dealNotes" add constraint "dealNotes_sales_id_fkey" FOREIGN KEY (sales_id) REFERENCES sales(id) not valid;

alter table "public"."dealNotes" validate constraint "dealNotes_sales_id_fkey";

alter table "public"."deals" add constraint "deals_company_id_fkey" FOREIGN KEY (company_id) REFERENCES companies(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."deals" validate constraint "deals_company_id_fkey";

alter table "public"."deals" add constraint "deals_sales_id_fkey" FOREIGN KEY (sales_id) REFERENCES sales(id) not valid;

alter table "public"."deals" validate constraint "deals_sales_id_fkey";

alter table "public"."sales" add constraint "sales_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."sales" validate constraint "sales_user_id_fkey";

alter table "public"."tasks" add constraint "tasks_contact_id_fkey" FOREIGN KEY (contact_id) REFERENCES contacts(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."tasks" validate constraint "tasks_contact_id_fkey";

set check_function_bodies = off;

grant delete on table "public"."companies" to "authenticated";
grant insert on table "public"."companies" to "authenticated";
grant select on table "public"."companies" to "authenticated";
grant update on table "public"."companies" to "authenticated";

grant delete on table "public"."companies" to "service_role";
grant insert on table "public"."companies" to "service_role";
grant references on table "public"."companies" to "service_role";
grant select on table "public"."companies" to "service_role";
grant trigger on table "public"."companies" to "service_role";
grant truncate on table "public"."companies" to "service_role";
grant update on table "public"."companies" to "service_role";

grant delete on table "public"."contactNotes" to "authenticated";
grant insert on table "public"."contactNotes" to "authenticated";
grant select on table "public"."contactNotes" to "authenticated";
grant update on table "public"."contactNotes" to "authenticated";

grant delete on table "public"."contactNotes" to "service_role";
grant insert on table "public"."contactNotes" to "service_role";
grant references on table "public"."contactNotes" to "service_role";
grant select on table "public"."contactNotes" to "service_role";
grant trigger on table "public"."contactNotes" to "service_role";
grant truncate on table "public"."contactNotes" to "service_role";
grant update on table "public"."contactNotes" to "service_role";

grant delete on table "public"."contacts" to "authenticated";
grant insert on table "public"."contacts" to "authenticated";
grant select on table "public"."contacts" to "authenticated";
grant update on table "public"."contacts" to "authenticated";

grant delete on table "public"."contacts" to "service_role";
grant insert on table "public"."contacts" to "service_role";
grant references on table "public"."contacts" to "service_role";
grant select on table "public"."contacts" to "service_role";
grant trigger on table "public"."contacts" to "service_role";
grant truncate on table "public"."contacts" to "service_role";
grant update on table "public"."contacts" to "service_role";

grant delete on table "public"."dealNotes" to "authenticated";
grant insert on table "public"."dealNotes" to "authenticated";
grant select on table "public"."dealNotes" to "authenticated";
grant update on table "public"."dealNotes" to "authenticated";

grant delete on table "public"."dealNotes" to "service_role";
grant insert on table "public"."dealNotes" to "service_role";
grant references on table "public"."dealNotes" to "service_role";
grant select on table "public"."dealNotes" to "service_role";
grant trigger on table "public"."dealNotes" to "service_role";
grant truncate on table "public"."dealNotes" to "service_role";
grant update on table "public"."dealNotes" to "service_role";


grant delete on table "public"."deals" to "authenticated";
grant insert on table "public"."deals" to "authenticated";
grant select on table "public"."deals" to "authenticated";
grant update on table "public"."deals" to "authenticated";

grant delete on table "public"."deals" to "service_role";
grant insert on table "public"."deals" to "service_role";
grant references on table "public"."deals" to "service_role";
grant select on table "public"."deals" to "service_role";
grant trigger on table "public"."deals" to "service_role";
grant truncate on table "public"."deals" to "service_role";
grant update on table "public"."deals" to "service_role";

grant delete on table "public"."sales" to "authenticated";
grant insert on table "public"."sales" to "authenticated";
grant select on table "public"."sales" to "authenticated";
grant update on table "public"."sales" to "authenticated";

grant delete on table "public"."sales" to "service_role";
grant insert on table "public"."sales" to "service_role";
grant references on table "public"."sales" to "service_role";
grant select on table "public"."sales" to "service_role";
grant trigger on table "public"."sales" to "service_role";
grant truncate on table "public"."sales" to "service_role";
grant update on table "public"."sales" to "service_role";

grant delete on table "public"."tags" to "authenticated";
grant insert on table "public"."tags" to "authenticated";
grant select on table "public"."tags" to "authenticated";
grant update on table "public"."tags" to "authenticated";

grant delete on table "public"."tags" to "service_role";
grant insert on table "public"."tags" to "service_role";
grant references on table "public"."tags" to "service_role";
grant select on table "public"."tags" to "service_role";
grant trigger on table "public"."tags" to "service_role";
grant truncate on table "public"."tags" to "service_role";
grant update on table "public"."tags" to "service_role";

grant delete on table "public"."tasks" to "authenticated";
grant insert on table "public"."tasks" to "authenticated";
grant select on table "public"."tasks" to "authenticated";
grant update on table "public"."tasks" to "authenticated";

grant delete on table "public"."tasks" to "service_role";
grant insert on table "public"."tasks" to "service_role";
grant references on table "public"."tasks" to "service_role";
grant select on table "public"."tasks" to "service_role";
grant trigger on table "public"."tasks" to "service_role";
grant truncate on table "public"."tasks" to "service_role";
grant update on table "public"."tasks" to "service_role";

create policy "Enable insert for authenticated users only"
on "public"."companies"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for authenticated users"
on "public"."companies"
as permissive
for select
to authenticated
using (true);


create policy "Enable update for authenticated users only"
on "public"."companies"
as permissive
for update
to authenticated
using (true)
with check (true);


create policy "Enable insert for authenticated users only"
on "public"."contactNotes"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for authenticated users"
on "public"."contactNotes"
as permissive
for select
to authenticated
using (true);


create policy "Enable insert for authenticated users only"
on "public"."contacts"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for authenticated users"
on "public"."contacts"
as permissive
for select
to authenticated
using (true);


create policy "Enable update for authenticated users only"
on "public"."contacts"
as permissive
for update
to authenticated
using (true)
with check (true);


create policy "Enable insert for authenticated users only"
on "public"."dealNotes"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for authenticated users"
on "public"."dealNotes"
as permissive
for select
to authenticated
using (true);


create policy "Enable insert for authenticated users only"
on "public"."deals"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for authenticated users"
on "public"."deals"
as permissive
for select
to authenticated
using (true);


create policy "Enable update for authenticated users only"
on "public"."deals"
as permissive
for update
to authenticated
using (true)
with check (true);


create policy "Enable insert for authenticated users only"
on "public"."sales"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable update for authenticated users only"
on "public"."sales"
as permissive
for update
to authenticated
using (true)
with check (true);


create policy "Enable read access for authenticated users"
on "public"."sales"
as permissive
for select
to authenticated
using (true);


create policy "Enable insert for authenticated users only"
on "public"."tags"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for authenticated users"
on "public"."tags"
as permissive
for select
to authenticated
using (true);


create policy "Enable insert for authenticated users only"
on "public"."tasks"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for authenticated users"
on "public"."tasks"
as permissive
for select
to authenticated
using (true);


create policy "Company Delete Policy"
on "public"."companies"
as permissive
for delete
to authenticated
using (true);


create policy "Contact Notes Delete Policy"
on "public"."contactNotes"
as permissive
for delete
to authenticated
using (true);


create policy "Contact Notes Update policy"
on "public"."contactNotes"
as permissive
for update
to authenticated
using (true);


create policy "Contact Delete Policy"
on "public"."contacts"
as permissive
for delete
to authenticated
using (true);


create policy "Deal Notes Delete Policy"
on "public"."dealNotes"
as permissive
for delete
to authenticated
using (true);


create policy "Deal Notes Update Policy"
on "public"."dealNotes"
as permissive
for update
to authenticated
using (true);


create policy "Deals Delete Policy"
on "public"."deals"
as permissive
for delete
to authenticated
using (true);


create policy "Task Delete Policy"
on "public"."tasks"
as permissive
for delete
to authenticated
using (true);


create policy "Task Update Policy"
on "public"."tasks"
as permissive
for update
to authenticated
using (true);


-- Use Postgres to create a bucket.

insert into storage.buckets
  (id, name, public)
values
  ('attachments', 'attachments', true);

CREATE POLICY "Attachments 1mt4rzk_0" ON storage.objects FOR SELECT TO authenticated USING (bucket_id = 'attachments');
CREATE POLICY "Attachments 1mt4rzk_1" ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'attachments');
CREATE POLICY "Attachments 1mt4rzk_3" ON storage.objects FOR DELETE TO authenticated USING (bucket_id = 'attachments');

-- Use Postgres to create views for companies.

create view "public"."companies_summary"
    with (security_invoker=on)
    as
select 
    c.*,
    count(distinct d.id) as nb_deals,
    count(distinct co.id) as nb_contacts
from 
    "public"."companies" c
left join 
    "public"."deals" d on c.id = d.company_id
left join 
    "public"."contacts" co on c.id = co.company_id
group by 
    c.id;
    
-- Use Postgres to create views for contacts.

create view "public"."contacts_summary"
    with (security_invoker=on)
    as
select 
    co.*,
    c.name as company_name,
    count(distinct t.id) as nb_tasks
from
    "public"."contacts" co
left join
    "public"."tasks" t on co.id = t.contact_id
left join
    "public"."companies" c on co.company_id = c.id
group by
    co.id, c.name;


create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = ''
as $$
declare
  sales_count int;
begin
  select count(id) into sales_count
  from public.sales;

  insert into public.sales (first_name, last_name, email, user_id, administrator)
  values (
    new.raw_user_meta_data ->> 'first_name', 
    new.raw_user_meta_data ->> 'last_name', 
    new.email, 
    new.id, 
    case when sales_count > 0 then FALSE else TRUE end
  );
  return new;
end;
$$;

create function public.handle_update_user()
returns trigger
language plpgsql
security definer set search_path = ''
as $$
begin
  update public.sales
  set 
    first_name = new.raw_user_meta_data ->> 'first_name', 
    last_name = new.raw_user_meta_data ->> 'last_name', 
    email = new.email
  where user_id = new.id;

  return new;
end;
$$;


create unique index "uq__sales__user_id" on public.sales (user_id);

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

create trigger on_auth_user_updated
  after update on auth.users
  for each row execute procedure public.handle_update_user();

create view init_state
  with (security_invoker=off)
  as
select count(id) as is_initialized
from public.sales
limit 1;
alter table "public"."tasks" add column "sales_id" bigint;-- this will drop the `contacts_summary` view as well
ALTER TABLE  "public"."contacts"
DROP COLUMN acquisition CASCADE;

 -- We need to recreate the view with the new schema

create view "public"."contacts_summary"
as
select 
    co.*,
    c.name as company_name,
    count(distinct t.id) as nb_tasks
from
    "public"."contacts" co
left join
    "public"."tasks" t on co.id = t.contact_id
left join
    "public"."companies" c on co.company_id = c.id
group by
    co.id, c.name;
create or replace view init_state
  with (security_invoker=off)
  as
select count(id) as is_initialized
from (
  select id 
  from public.sales
  limit 1
) as sub;
create policy "Enable delete for authenticated users only"
on "public"."tags"
as permissive
for delete
to authenticated
using (true);


create policy "Enable update for authenticated users only"
on "public"."tags"
as permissive
for update
to authenticated
using (true);




create schema if not exists "private";

set check_function_bodies = off;

drop policy "Enable insert for authenticated users only" on "public"."sales";

drop policy "Enable update for authenticated users only" on "public"."sales";
alter table contacts add column email_jsonb jsonb;

update contacts set email_jsonb = ('[{"email": "' || email || '", "type": "Other"}]')::jsonb;

drop view contacts_summary;

alter table contacts drop column email;

create view contacts_summary
as
select 
    co.id,
    co.first_name,
    co.last_name,
    co.gender,
    co.title,
    co.email_jsonb,
    jsonb_path_query_array(co.email_jsonb, '$[*].email')::text as email_fts,
    co.phone_1_number,
    co.phone_1_type,
    co.phone_2_number,
    co.phone_2_type,
    co.background,
    co.avatar,
    co.first_seen,
    co.last_seen,
    co.has_newsletter,
    co.status,
    co.tags,
    co.company_id,
    co.sales_id,
    co.linkedin_url,
    c.name as company_name,
    count(distinct t.id) as nb_tasks
from
    contacts co
left join
    tasks t on co.id = t.contact_id
left join
    companies c on co.company_id = c.id
group by
    co.id, c.name;

alter table contacts add column phone_jsonb jsonb;

update contacts set phone_jsonb = 
    concat(
        '[',
        case when phone_1_number is not null then 
            concat(
                '{"number":"', 
                phone_1_number, 
                '","type":"',
                phone_1_type,
                '"}'
            )
        else null end,
        case when phone_2_number is not null then 
            concat(
                ',',
                '{"number":"', 
                phone_2_number, 
                '","type":"',
                phone_2_type,
                '"}'
            )
        else null end,
        ']'
    )::jsonb;

drop view contacts_summary;

alter table contacts drop column phone_1_number;
alter table contacts drop column phone_1_type;
alter table contacts drop column phone_2_number;
alter table contacts drop column phone_2_type;

create view contacts_summary
as
select 
    co.id,
    co.first_name,
    co.last_name,
    co.gender,
    co.title,
    co.email_jsonb,
    jsonb_path_query_array(co.email_jsonb, '$[*].email')::text as email_fts,
    co.phone_jsonb,
    jsonb_path_query_array(co.phone_jsonb, '$[*].number')::text as phone_fts,
    co.background,
    co.avatar,
    co.first_seen,
    co.last_seen,
    co.has_newsletter,
    co.status,
    co.tags,
    co.company_id,
    co.sales_id,
    co.linkedin_url,
    c.name as company_name,
    count(distinct t.id) as nb_tasks
from
    contacts co
left join
    tasks t on co.id = t.contact_id
left join
    companies c on co.company_id = c.id
group by
    co.id, c.name;

-- Create function to merge contacts server-side with transaction support
CREATE OR REPLACE FUNCTION merge_contacts(loser_id bigint, winner_id bigint)
RETURNS bigint
LANGUAGE plpgsql
SECURITY INVOKER
AS $$
DECLARE
  winner_contact contacts%ROWTYPE;
  loser_contact contacts%ROWTYPE;
  deal_record RECORD;
  merged_emails jsonb;
  merged_phones jsonb;
  merged_tags bigint[];
  winner_emails jsonb;
  loser_emails jsonb;
  winner_phones jsonb;
  loser_phones jsonb;
  email_map jsonb;
  phone_map jsonb;
BEGIN
  -- Fetch both contacts
  SELECT * INTO winner_contact FROM contacts WHERE id = winner_id;
  SELECT * INTO loser_contact FROM contacts WHERE id = loser_id;

  IF winner_contact IS NULL OR loser_contact IS NULL THEN
    RAISE EXCEPTION 'Contact not found';
  END IF;

  -- 1. Reassign tasks from loser to winner
  UPDATE tasks SET contact_id = winner_id WHERE contact_id = loser_id;

  -- 2. Reassign contact notes from loser to winner
  UPDATE "contactNotes" SET contact_id = winner_id WHERE contact_id = loser_id;

  -- 3. Update deals - replace loser with winner in contact_ids array
  FOR deal_record IN
    SELECT id, contact_ids
    FROM deals
    WHERE contact_ids @> ARRAY[loser_id]
  LOOP
    UPDATE deals
    SET contact_ids = (
      SELECT ARRAY(
        SELECT DISTINCT unnest(
          array_remove(deal_record.contact_ids, loser_id) || ARRAY[winner_id]
        )
      )
    )
    WHERE id = deal_record.id;
  END LOOP;

  -- 4. Merge contact data

  -- Get email arrays
  winner_emails := COALESCE(winner_contact.email_jsonb, '[]'::jsonb);
  loser_emails := COALESCE(loser_contact.email_jsonb, '[]'::jsonb);

  -- Merge emails with deduplication by email address
  -- Build a map of email -> email object, then convert back to array
  email_map := '{}'::jsonb;

  -- Add winner emails to map
  IF jsonb_array_length(winner_emails) > 0 THEN
    FOR i IN 0..jsonb_array_length(winner_emails)-1 LOOP
      email_map := email_map || jsonb_build_object(
        winner_emails->i->>'email',
        winner_emails->i
      );
    END LOOP;
  END IF;

  -- Add loser emails to map (won't overwrite existing keys)
  IF jsonb_array_length(loser_emails) > 0 THEN
    FOR i IN 0..jsonb_array_length(loser_emails)-1 LOOP
      IF NOT email_map ? (loser_emails->i->>'email') THEN
        email_map := email_map || jsonb_build_object(
          loser_emails->i->>'email',
          loser_emails->i
        );
      END IF;
    END LOOP;
  END IF;

  -- Convert map back to array
  merged_emails := (SELECT jsonb_agg(value) FROM jsonb_each(email_map));
  merged_emails := COALESCE(merged_emails, '[]'::jsonb);

  -- Get phone arrays
  winner_phones := COALESCE(winner_contact.phone_jsonb, '[]'::jsonb);
  loser_phones := COALESCE(loser_contact.phone_jsonb, '[]'::jsonb);

  -- Merge phones with deduplication by number
  phone_map := '{}'::jsonb;

  -- Add winner phones to map
  IF jsonb_array_length(winner_phones) > 0 THEN
    FOR i IN 0..jsonb_array_length(winner_phones)-1 LOOP
      phone_map := phone_map || jsonb_build_object(
        winner_phones->i->>'number',
        winner_phones->i
      );
    END LOOP;
  END IF;

  -- Add loser phones to map (won't overwrite existing keys)
  IF jsonb_array_length(loser_phones) > 0 THEN
    FOR i IN 0..jsonb_array_length(loser_phones)-1 LOOP
      IF NOT phone_map ? (loser_phones->i->>'number') THEN
        phone_map := phone_map || jsonb_build_object(
          loser_phones->i->>'number',
          loser_phones->i
        );
      END IF;
    END LOOP;
  END IF;

  -- Convert map back to array
  merged_phones := (SELECT jsonb_agg(value) FROM jsonb_each(phone_map));
  merged_phones := COALESCE(merged_phones, '[]'::jsonb);

  -- Merge tags (remove duplicates)
  merged_tags := ARRAY(
    SELECT DISTINCT unnest(
      COALESCE(winner_contact.tags, ARRAY[]::bigint[]) ||
      COALESCE(loser_contact.tags, ARRAY[]::bigint[])
    )
  );

  -- 5. Update winner with merged data
  UPDATE contacts SET
    avatar = COALESCE(winner_contact.avatar, loser_contact.avatar),
    gender = COALESCE(winner_contact.gender, loser_contact.gender),
    first_name = COALESCE(winner_contact.first_name, loser_contact.first_name),
    last_name = COALESCE(winner_contact.last_name, loser_contact.last_name),
    title = COALESCE(winner_contact.title, loser_contact.title),
    company_id = COALESCE(winner_contact.company_id, loser_contact.company_id),
    email_jsonb = merged_emails,
    phone_jsonb = merged_phones,
    linkedin_url = COALESCE(winner_contact.linkedin_url, loser_contact.linkedin_url),
    background = COALESCE(winner_contact.background, loser_contact.background),
    has_newsletter = COALESCE(winner_contact.has_newsletter, loser_contact.has_newsletter),
    first_seen = LEAST(COALESCE(winner_contact.first_seen, loser_contact.first_seen), COALESCE(loser_contact.first_seen, winner_contact.first_seen)),
    last_seen = GREATEST(COALESCE(winner_contact.last_seen, loser_contact.last_seen), COALESCE(loser_contact.last_seen, winner_contact.last_seen)),
    sales_id = COALESCE(winner_contact.sales_id, loser_contact.sales_id),
    tags = merged_tags
  WHERE id = winner_id;

  -- 6. Delete loser contact
  DELETE FROM contacts WHERE id = loser_id;

  RETURN winner_id;
END;
$$;
-- Drop the merge_contacts function (reverting to edge function approach)
DROP FUNCTION IF EXISTS merge_contacts(bigint, bigint);
